import datetime
import os
from reportlab.lib.pagesizes import A4
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
import sqlite3

def parse_date(date_str):
    """
    Parse date string in format DD.MM.YYYY and return datetime object

    Args:
        date_str (str): Date in format DD.MM.YYYY

    Returns:
        datetime.datetime: Parsed datetime object or None if invalid
    """
    if not date_str or date_str == '-':
        return None

    try:
        return datetime.datetime.strptime(date_str, "%d.%m.%Y")
    except ValueError:
        return None

def days_until(date_str):
    """
    Calculate days until given date

    Args:
        date_str (str): Date in format DD.MM.YYYY

    Returns:
        int: Days until date or None if date is invalid
    """
    date_obj = parse_date(date_str)
    if not date_obj:
        return None

    days = (date_obj - datetime.datetime.now()).days
    return days

def format_days_remaining(days):
    """
    Format days remaining with colors and warning symbols

    Args:
        days (int): Number of days

    Returns:
        str: Formatted string with emoji and days count
    """
    if days is None:
        return "‚ùì –ù–µ –∑–∞–¥–∞–Ω–æ"

    if days < 0:
        return f"üö´ –ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ ({-days} –¥–Ω.)"
    elif days <= 7:
        return f"‚ö†Ô∏è –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ ({days} –¥–Ω.)"
    elif days <= 30:
        return f"‚ö†Ô∏è –°–∫–æ—Ä–æ ({days} –¥–Ω.)"
    else:
        return f"‚úÖ {days} –¥–Ω."

def get_to_interval_based_on_mileage(last_to_mileage, current_mileage, interval=10000):
    """
    Calculate remaining kilometers until next TO based on interval

    Args:
        last_to_mileage (int): Mileage at last TO
        current_mileage (int): Current mileage
        interval (int): TO interval in kilometers (default 10000)

    Returns:
        int: Kilometers until next TO
    """
    if not last_to_mileage:
        return None

    next_to_mileage = last_to_mileage + interval
    remaining = next_to_mileage - current_mileage

    return remaining, next_to_mileage

def edit_fuel_info(vehicle_id, fuel_type=None, fuel_tank_capacity=None, avg_fuel_consumption=None):
    """
    Edit fuel information for a vehicle

    Args:
        vehicle_id (int): Vehicle ID
        fuel_type (str, optional): Fuel type
        fuel_tank_capacity (float, optional): Fuel tank capacity in liters
        avg_fuel_consumption (float, optional): Average fuel consumption in l/100km

    Returns:
        bool: True if updated successfully
    """
    conn = sqlite3.connect('vehicles.db')
    cursor = conn.cursor()

    # Create SET clause parts based on provided values
    updates = []
    params = []

    if fuel_type is not None:
        updates.append("fuel_type = ?")
        params.append(fuel_type)

    if fuel_tank_capacity is not None:
        updates.append("fuel_tank_capacity = ?")
        params.append(fuel_tank_capacity)

    if avg_fuel_consumption is not None:
        updates.append("avg_fuel_consumption = ?")
        params.append(avg_fuel_consumption)

    if not updates:  # No fields to update
        conn.close()
        return False

    # Add vehicle_id to params
    params.append(vehicle_id)

    # Execute the update
    try:
        cursor.execute(
            f"UPDATE vehicles SET {', '.join(updates)} WHERE id = ?",
            params
        )
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        conn.close()
        print(f"Error updating fuel info: {e}")
        return False

def generate_expiration_report():
    """
    Generate PDF report with all vehicles and their document expiration dates

    Returns:
        str: Path to the generated PDF file
    """
    import logging  # –î–æ–±–∞–≤–∏–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏

    # Get today's date
    today = datetime.datetime.now()
    filename = f"report_{today.strftime('%Y%m%d')}.pdf"

    # Connect to the database
    conn = sqlite3.connect('vehicles.db')
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    # Get all vehicles with their expiration dates
    cursor.execute("""
        SELECT id, model, reg_number, osago_valid, tech_inspection_valid,
               skzi_valid_date, mileage, tachograph_required, next_to
        FROM vehicles
        ORDER BY model
    """)
    vehicles = cursor.fetchall()

    # Register appropriate fonts with Cyrillic support
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont

    # –õ–æ–∫–∞–ª—å–Ω—ã–µ –ø—É—Ç–∏ –∫ —à—Ä–∏—Ñ—Ç–∞–º (–Ω—É–∂–Ω–æ –ø–æ–ª–æ–∂–∏—Ç—å —Ñ–∞–π–ª—ã –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –ø—Ä–æ–µ–∫—Ç–∞)
    font_regular = 'DejaVuSans.ttf'
    font_bold = 'DejaVuSans-Bold.ttf'

    # –ü–æ–ø—Ä–æ–±—É–µ–º –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —à—Ä–∏—Ñ—Ç—ã
    cyrillic_font = 'Helvetica'  # –ó–∞–ø–∞—Å–Ω–æ–π —à—Ä–∏—Ñ—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    cyrillic_font_bold = 'Helvetica-Bold'

    try:
        if os.path.exists(font_regular) and os.path.exists(font_bold):
            pdfmetrics.registerFont(TTFont('CustomFont', font_regular))
            pdfmetrics.registerFont(TTFont('CustomFontBold', font_bold))
            cyrillic_font = 'CustomFont'
            cyrillic_font_bold = 'CustomFontBold'
            logging.info("–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ª–æ–∫–∞–ª—å–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã DejaVuSans")
        else:
            # –ü–æ–ø—Ä–æ–±—É–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –ø—É—Ç–∏
            system_font = '/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf'
            system_font_bold = '/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf'
            if os.path.exists(system_font) and os.path.exists(system_font_bold):
                pdfmetrics.registerFont(TTFont('CustomFont', system_font))
                pdfmetrics.registerFont(TTFont('CustomFontBold', system_font_bold))
                cyrillic_font = 'CustomFont'
                cyrillic_font_bold = 'CustomFontBold'
                logging.info("–ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Å–∏—Å—Ç–µ–º–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã DejaVuSans")
            else:
                logging.warning("–®—Ä–∏—Ñ—Ç—ã DejaVuSans –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è Helvetica (–±–µ–∑ –ø–æ–ª–Ω–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∫–∏—Ä–∏–ª–ª–∏—Ü—ã)")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —à—Ä–∏—Ñ—Ç–æ–≤: {e}")
        logging.info("–ü–∞–¥–µ–Ω–∏–µ –Ω–∞ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —à—Ä–∏—Ñ—Ç—ã Helvetica")

    # Create the PDF document
    doc = SimpleDocTemplate(filename, pagesize=A4)
    styles = getSampleStyleSheet()

    # Create custom styles for Cyrillic text
    cyrillic_normal = ParagraphStyle(
        'CyrillicNormal',
        parent=styles['Normal'],
        fontName=cyrillic_font,
        fontSize=10,
        leading=14,
        encoding='utf-8',
        alignment=1
    )

    cyrillic_title = ParagraphStyle(
        'CyrillicTitle',
        parent=styles['Heading1'],
        fontName=cyrillic_font_bold,
        fontSize=16,
        leading=20,
        alignment=1,
        spaceAfter=20,
        encoding='utf-8'
    )

    # Add title and date
    elements = []
    title_text = "–û—Ç—á–µ—Ç –æ–± –∏—Å—Ç–µ—á–µ–Ω–∏–∏ —Å—Ä–æ–∫–æ–≤ –¥–æ–∫—É–º–µ–Ω—Ç–æ–≤"
    date_text = f"–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è: {today.strftime('%d.%m.%Y')}"

    elements.append(Paragraph(title_text, cyrillic_title))
    elements.append(Paragraph(date_text, cyrillic_normal))
    elements.append(Spacer(1, 20))

    # Create data for the table
    headers = ["–¢—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–æ–µ —Å—Ä–µ–¥—Å—Ç–≤–æ", "–û–°–ê–ì–û", "–¢–µ—Ö–æ—Å–º–æ—Ç—Ä", "–°–ö–ó–ò", "–¢–û"]
    data = [headers]

    for vehicle in vehicles:
        osago_days = days_until(vehicle['osago_valid'])
        tech_days = days_until(vehicle['tech_inspection_valid'])
        skzi_days = days_until(vehicle['skzi_valid_date']) if vehicle['tachograph_required'] else None

        if vehicle['next_to']:
            remaining_to = vehicle['next_to'] - vehicle['mileage']
            if remaining_to <= 0:
                to_status = f"–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ ({-remaining_to} –∫–º)"
            elif remaining_to <= 500:
                to_status = f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏ ({remaining_to} –∫–º)"
            elif remaining_to <= 1000:
                to_status = f"–°–∫–æ—Ä–æ ({remaining_to} –∫–º)"
            else:
                to_status = f"{remaining_to} –∫–º"
        else:
            to_status = "–ù–µ –∑–∞–¥–∞–Ω–æ"

        vehicle_text = f"{vehicle['model']} ({vehicle['reg_number']})"

        if osago_days is not None and osago_days < 0:
            osago_text = f"-{-osago_days} –¥–Ω."
        else:
            osago_text = format_days_remaining(osago_days).replace("‚ö†Ô∏è", "!").replace("‚úÖ", "+").replace("üö´", "X").replace("‚ùì", "?").replace("–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ", "-").replace("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏", "!")

        if tech_days is not None and tech_days < 0:
            tech_text = f"-{-tech_days} –¥–Ω."
        else:
            tech_text = format_days_remaining(tech_days).replace("‚ö†Ô∏è", "!").replace("‚úÖ", "+").replace("üö´", "X").replace("‚ùì", "?").replace("–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ", "-").replace("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏", "!")

        if vehicle['tachograph_required']:
            if skzi_days is not None and skzi_days < 0:
                skzi_text = f"-{-skzi_days} –¥–Ω."
            else:
                skzi_text = format_days_remaining(skzi_days).replace("‚ö†Ô∏è", "!").replace("‚úÖ", "+").replace("üö´", "X").replace("‚ùì", "?").replace("–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ", "-").replace("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏", "!")
        else:
            skzi_text = "–ù–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è"

        if vehicle['next_to']:
            remaining_to = vehicle['next_to'] - vehicle['mileage']
            if remaining_to <= 0:
                to_status = f"-{-remaining_to} –∫–º"
            elif remaining_to <= 500:
                to_status = f"!{remaining_to} –∫–º"
            elif remaining_to <= 1000:
                to_status = f"!{remaining_to} –∫–º"
            else:
                to_status = f"{remaining_to} –∫–º"
        else:
            to_status = "–ù–µ –∑–∞–¥–∞–Ω–æ"

        row = [vehicle_text, osago_text, tech_text, skzi_text, to_status]
        data.append(row)

    # Create table
    table = Table(data, colWidths=[170, 90, 90, 90, 90])

    table_style = TableStyle([
        ('BACKGROUND', (0, 0), (-1, 0), colors.darkblue),
        ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
        ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), cyrillic_font_bold),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 8),
        ('TOPPADDING', (0, 0), (-1, 0), 8),
        ('BACKGROUND', (0, 1), (-1, -1), colors.white),
        ('TEXTCOLOR', (0, 1), (-1, -1), colors.black),
        ('FONTNAME', (0, 1), (-1, -1), cyrillic_font),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 1), (-1, -1), 6),
        ('TOPPADDING', (0, 1), (-1, -1), 6),
        ('GRID', (0, 0), (-1, -1), 0.5, colors.grey),
        ('BOX', (0, 0), (-1, -1), 1, colors.black),
        ('LINEBELOW', (0, 0), (-1, 0), 1, colors.black),
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (1, 1), (-1, -1), 'CENTER'),
        ('ALIGN', (0, 1), (0, -1), 'LEFT'),
        ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.whitesmoke, colors.white]),
    ])

    for i in range(1, len(data)):
        for j in range(1, 5):
            cell_data = str(data[i][j]).lower()
            if cell_data.startswith("-") or "–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏" in cell_data or "–ø—Ä–æ—Å—Ä–æ—á–µ–Ω–æ" in cell_data or "!" in cell_data:
                table_style.add('BACKGROUND', (j, i), (j, i), colors.mistyrose)
                table_style.add('TEXTCOLOR', (j, i), (j, i), colors.darkred)
            elif "—Å–∫–æ—Ä–æ" in cell_data:
                table_style.add('BACKGROUND', (j, i), (j, i), colors.lemonchiffon)
                table_style.add('TEXTCOLOR', (j, i), (j, i), colors.saddlebrown)

    table.setStyle(table_style)
    elements.append(table)

    # Build the PDF
    try:
        doc.build(elements)
        logging.info(f"PDF –æ—Ç—á–µ—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω: {filename}")
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–∫–µ PDF: {e}")
        raise

    conn.close()
    return filename
